const std = @import("std");
const fs = std.fs;
const io = std.io;
const process = std.process;
const unicode = std.unicode;

pub const AddExecutableOptions = struct {
    name: []const u8,
    module: *std.Build.Module,
};

const base_cpp_flags: []const []const u8 = &.{ "-std=c++23", "-Wall" };
var igfx_core_lib: *std.Build.Step.Compile = undefined;

pub fn addExecutable(
    b: *std.Build,
    options: AddExecutableOptions,
) *std.Build.Step.Compile {
    const user_code_mod = options.module;
    const target = user_code_mod.resolved_target.?;
    const optimize = user_code_mod.optimize.?;

    const igfx_core_mod = b.addModule("igfx_core", .{
        .target = target,
        .optimize = optimize,
        .link_libcpp = true,
    });

    igfx_core_mod.addCSourceFiles(.{
        .files = &.{
            "src/core/window.cpp",
            "src/core/graphics.cpp",
            "src/core/core.cpp",
            "src/core/engine.cpp",
        },
        .flags = base_cpp_flags ++ .{
            "-include",
            "src/pch.h",
        },
    });

    igfx_core_mod.addIncludePath(b.path("include"));
    igfx_core_mod.addIncludePath(b.path("src"));

    var vulkan_sdk_path: []const u8 = undefined;
    if (b.option([]const u8, "vulkan", "Specify the Vulkan SDK path")) |sdk_path| {
        vulkan_sdk_path = sdk_path;
    } else {
        const env_map = process.getEnvMap(b.allocator) catch @panic("OOM");
        vulkan_sdk_path = env_map.get("VULKAN_SDK") orelse {
            @panic("VULKAN_SDK env var not found ('-Dvulkan=...' to specify path)");
        };
    }

    igfx_core_mod.addIncludePath(.{
        .cwd_relative = b.pathJoin(&.{ vulkan_sdk_path, "Include" }),
    });

    igfx_core_mod.addLibraryPath(.{
        .cwd_relative = b.pathJoin(&.{ vulkan_sdk_path, "Lib" }),
    });

    switch (target.result.os.tag) {
        .windows => {
            igfx_core_mod.linkSystemLibrary("vulkan-1", .{
                .use_pkg_config = .no,
                .preferred_link_mode = .static,
            });
        },
        else => {
            igfx_core_mod.linkSystemLibrary("vulkan", .{
                .use_pkg_config = .no,
                .preferred_link_mode = .static,
            });
        }
    }

    const glfw = b.dependency("glfw", .{});
    igfx_core_mod.addIncludePath(glfw.path("glfw/include"));
    igfx_core_mod.linkLibrary(glfw.artifact("glfw"));

    igfx_core_lib = b.addLibrary(.{
        .name = "igfx_core",
        .root_module = igfx_core_mod,
    });

    const igfx_lib_mod = b.addModule("igfx_lib", .{
        .target = target,
        .optimize = optimize,
        .link_libcpp = true,
    });

    igfx_lib_mod.addCSourceFiles(.{
        .files = &.{
            "src/window.cpp",
            "src/graphics.cpp",
            "src/pch.cpp",
            "src/linalg.cpp",
        },
        .flags = base_cpp_flags ++ .{
            "-include",
            "src/pch.h",
        },
    });
    igfx_lib_mod.addIncludePath(b.path("include"));
    igfx_lib_mod.addIncludePath(b.path("src"));
    igfx_lib_mod.linkLibrary(igfx_core_lib);

    const igfx_lib = b.addLibrary(.{
        .name = "igfx",
        .root_module = igfx_lib_mod,
    });

    const igfx_exe_mod = b.addModule("igfx_exe", .{
        .target = target,
        .optimize = optimize,
        .link_libcpp = true,
    });

    igfx_exe_mod.addCSourceFiles(.{
        .files = &.{"src/main.cpp"},
        .flags = base_cpp_flags ++ .{
            "-include",
            "src/pch.h",
        },
    });

    igfx_exe_mod.addIncludePath(b.path("include"));
    igfx_exe_mod.addIncludePath(b.path("src"));

    igfx_exe_mod.linkLibrary(igfx_lib);
    igfx_exe_mod.linkLibrary(igfx_core_lib);

    user_code_mod.addIncludePath(b.path("include"));
    user_code_mod.link_libcpp = true;
    user_code_mod.linkLibrary(igfx_lib);

    const user_code_lib = b.addLibrary(.{
        .name = "user",
        .root_module = user_code_mod,
        .linkage = if (optimize == .Debug) .dynamic else .static,
    });

    const exe = b.addExecutable(.{
        .name = options.name,
        .root_module = igfx_exe_mod,
    });

    // Depending on the optimize mode either link statically or
    // provide a path to the dll enabling hot reload during debugging (TODO).
    if (optimize == .Debug) {
        const user_install = b.addInstallArtifact(user_code_lib, .{});
        const user_install_path = b.pathJoin(&.{
            b.install_path,
            "bin",
            user_install.dest_sub_path,
        });

        igfx_exe_mod.addCMacro("USER_DLL", b.fmt("R\"({s})\"", .{user_install_path}));
        exe.step.dependOn(&user_install.step);
    } else {
        igfx_exe_mod.linkLibrary(user_code_lib);
    }

    return exe;
}

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const example_exe_mod = b.createModule(.{
        .target = target,
        .optimize = optimize,
    });

    example_exe_mod.addCSourceFile(.{
        .file = b.path("example/src/main.cpp"),
        .flags = &.{"-std=c++23"},
    });

    const example_exe = addExecutable(b, .{
        .name = "example",
        .module = example_exe_mod,
    });

    b.installArtifact(example_exe);

    const run_cmd = b.addRunArtifact(example_exe);
    run_cmd.step.dependOn(b.getInstallStep());

    const run_step = b.step("run", "Run the example app");
    run_step.dependOn(&run_cmd.step);

    const cdb = @import("build/cdb.zig");
    const cdb_step = b.step("cdb", "Create compile_commands.json");
    cdb_step.dependOn(cdb.addStep(b, .{ .artifacts = &.{ igfx_core_lib, example_exe } }));
}
